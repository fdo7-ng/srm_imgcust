################################################################################
#  Copyright 2018 VMware, Inc.  All rights reserved.
################################################################################

package UbuntuNetplanCustomization;

# Inherit from Ubuntu15Customization.
use base qw(Ubuntu15Customization);

use strict;
use Debug;

my $UBUNTURELEASEFILE = "/etc/lsb-release";

my $NETPLANBYNETWORKMANAGERFILE = "/etc/netplan/01-network-manager-all.yaml";
my $NETPLANFILE = "/etc/netplan/99-netcfg-vmware.yaml";

#...............................................................................
#
# DetectDistroFlavour
#
#     Detects the flavour of the distribution.
#     Called by parent class DetectDistro method.
# Params:
#     None
#
# Result:
#     Returns the distribution flavour if the distro is supported by
#     the customization object, otherwise undef.
#
#...............................................................................

sub DetectDistroFlavour
{
   my ($self) = @_;
   my $result = undef;

   if (-e $Customization::ISSUEFILE) {
      DEBUG("Reading issue file ... ");
      my $issueContent = Utils::ExecuteCommand("cat $Customization::ISSUEFILE");
      DEBUG($issueContent);

      # Assume Ubuntu18 can also use the same code in this module
      # Otherwise, extend this module and add additional code.
      if ($issueContent =~ /Ubuntu\s+(17\.10|18\.(04|10))/i) {
         $result = "Ubuntu $1";
      }
   } else {
      WARN("Issue file not available. Ignoring it.");
   }
   # beta versions has /etc/issue file contents of form
   # Ubuntu Trusty Tahr (development branch) \n \l
   if(! defined $result) {
      if (-e $UBUNTURELEASEFILE) {
         my $lsbContent = Utils::ExecuteCommand("cat $UBUNTURELEASEFILE");
         if ($lsbContent =~ /DISTRIB_ID=Ubuntu/i and
             $lsbContent =~ /DISTRIB_RELEASE=(17\.10|18\.(04|10))/) {
            $result = "Ubuntu $1";
         }
      }
   }

   return $result;
}

#...............................................................................
#
# DetectDistro
#
#     Detects the distros that should use the customization code in this module
#
# Params:
#     None
#
# Result:
#     Returns
#        the distro Id if the customization code in this module should be
#           used for that distro.
#        undef otherwise.
#
#...............................................................................

sub DetectDistro
{
   my ($self) = @_;

   my $result = $self->DetectDistroFlavour();
   if ($result) {
      if (-e $NETPLANBYNETWORKMANAGERFILE) {
         # Mixing systemd-networkd with the NetworkManager in
         # netplan settings are problematic. Simplify our life
         # by having just one single network management service.
         # Experiments show that the network manager is not really disabled
         # even its corresponding netplan file is removed.
         # If network manager is being used by the netplan,
         # then keep that way and customize the /etc/network/interfaces file.
         return undef;
      }
   }

   return $result;
}

#...............................................................................
#
# AppendYaml
#
#     Helper function to construct a Yaml.
#
# Params:
#     @yaml                 lines of the yaml content being constructed.
#     $level                indentation level.
#     $text                 a new line content.
#
# Result:
#     None.
#
#...............................................................................

sub AppendYaml
{
   my ($yaml, $level, $text) = @_;
   push(@$yaml, "  " x $level . $text . "\n");
}

#...............................................................................
#
# CustomizeNICS
#
#   Customize network interface.
#   Ubuntu17 and future distros use the netplan based network configuration.
#   man (5) netplan.
#   Configuration of /etc/network/interfaces is no longer used except for
#   the local loop back interface.
#
# Params & Result:
#   None
#
#...............................................................................

sub CustomizeNICS
{
   my ($self) = @_;

   # get information on the NICS to configure
   my $nicsToConfigure = $self->{_customizationConfig}->Lookup("NIC-CONFIG|NICS");

   # split the string by ","
   my @nics = split(/,/, $nicsToConfigure);

   if (not @nics) {
      return;
   }

   INFO("Customizing NICS. { $nicsToConfigure }");

   $self->{_netplan} = [];

   AppendYaml($self->{_netplan}, 0,
              "# Generated by VMWare customization engine.");
   AppendYaml($self->{_netplan}, 0, "network:");
   AppendYaml($self->{_netplan}, 1, "version: 2");
   AppendYaml($self->{_netplan}, 1, "renderer: networkd");
   AppendYaml($self->{_netplan}, 1, "ethernets:");

   # iterate through each NIC
   foreach my $nic (@nics) {
      INFO("Customizing NIC $nic");
      $self->CustomizeSpecificNIC($nic);
   }

   # Drop our yaml file under /etc/netplan, as long as the file name
   # is lexicographically later than other files in the directory, it
   # shall amend and override previous ones. This saves us the effort
   # of parsing the old files. Instead of replacing lines in old files,
   # we can create a new one and modify the settings in the new file
   # without touching the ones provided by the system and the users.

   Utils::WriteBufferToFile($NETPLANFILE, $self->{_netplan});
   Utils::SetPermission($NETPLANFILE, $Utils::RWRR);

   # We need to restart the network explicitly because there is no deterministic
   # order about when the guest customization was run by the toolsd vs.
   # when the system loads the netplan setting and start the network.

   $self->RestartNetwork();
}

#...............................................................................
#
# CountBits
#
#   Count the number of one bits set in a byte.
#
# Params:
#   $value  a byte value.
#
# Result:
#   The number of one bits set.
#
#...............................................................................

sub CountBits
{
   my ($value) = @_;
   if ($value < 0 || $value > 255) {
      die "Input $value is out of range.";
   }

   $value -= ($value >> 1) & 0x55; # 0101 0101
   $value = ($value & 0x33) + (($value >> 2) & 0x33); # 0011 0011
   $value = ($value + ($value >> 4)) & 0x0f;

   return $value;
}

#...............................................................................
#
# GetIpv4Address
#
#   Get the IP v4 address/netmask format string to set in netplan yaml.
#   Note that our spec only supports one IP v4 address per NIC.
#   This is why we are returning a scalar.
#
# Params:
#   $nic    The associated network card.
#
# Result:
#   A netplan formatted IP/netmask address.
#
#...............................................................................

sub GetIpv4Address
{
   my ($self, $nic) = @_;

   my $ipaddr      = $self->{_customizationConfig}->Lookup($nic . "|IPADDR");
   my $netmask     = $self->{_customizationConfig}->Lookup($nic . "|NETMASK");

   if (!$ipaddr) {
      return undef;
   }

   my @parts = split(/\./, $netmask);
   my $len = 0;
   for my $part (@parts) {
      $len += CountBits($part);
   }

   return $ipaddr . "/" . $len;
}

#...............................................................................
#
# GetIpv6Addresses
#
#   Get the IP v6 address/netmask format strings to set in netplan yaml.
#   Note that our spec supporst multiple IP v6 addresses per NIC.
#   This is why we are returning an array.
#
# Params:
#   $nic    The associated network card.
#
# Result:
#   An array of netplan formatted IP/netmask addresses.
#
#...............................................................................

sub GetIpv6Addresses
{
   my ($self, $nic) = @_;

   my @ipv6Addresses = ConfigFile::ConvertToIndexedArray(
      $self->{_customizationConfig}->Query("^($nic\\|IPv6ADDR\\|)"));

   my @ipv6Netmasks = ConfigFile::ConvertToIndexedArray(
      $self->{_customizationConfig}->Query("^($nic\\|IPv6NETMASK\\|)"));

   my @ipv6Settings = ConfigFile::Transpose(\@ipv6Addresses, \@ipv6Netmasks);

   my @addresses;
   for my $setting (@ipv6Settings) {
      push(@addresses, $setting->[0] . "/" . $setting->[1]);
   }

   return @addresses;
}

#...............................................................................
#
# CustomizeSpecificNIC
#
#   Generate netplan specifics for a network card.
#   Ubuntu17 and future distros use the netplan based network configuration.
#   man (5) netplan.
#   Configuration of /etc/network/interfaces is no longer used except for
#   the local loop back interface.
#
#   Unlike /etc/network/interfaces, netplan supports only one Ipv4 gateway,
#   and one Ipv6 gateway, and requires the DNS setting in each NIC section.
#
# Params
#   $nic     The associated network card.
#
# Result:
#   None.
#
#...............................................................................

sub CustomizeSpecificNIC
{
   my ($self, $nic) = @_;

   # get the params
   my $macaddr     = $self->{_customizationConfig}->Lookup($nic . "|MACADDR");
   my $bootproto   = $self->{_customizationConfig}->Lookup($nic . "|BOOTPROTO");

   # get the network suffix
   my $interface = $self->GetInterfaceByMacAddress($macaddr);

   if (!$interface) {
      die "Error finding the specified NIC for MAC address = $macaddr";
   };

   INFO ("NIC suffix = $interface");

   AppendYaml($self->{_netplan}, 2, $interface . ":");

   if ($bootproto =~ /dhcp/i) {
      AppendYaml($self->{_netplan}, 3, "dhcp4: yes");
      AppendYaml($self->{_netplan}, 3, "dhcp6: yes");
   } else {
      AppendYaml($self->{_netplan}, 3, "dhcp4: no");
      AppendYaml($self->{_netplan}, 3, "dhcp6: no");
   }

   my @addresses;

   my $ipv4 = $self->GetIpv4Address($nic);
   if ($ipv4) {
      push(@addresses, $ipv4);
   }

   my @ipv6s = $self->GetIpv6Addresses($nic);

   push(@addresses, @ipv6s);

   if (@addresses) {
      AppendYaml($self->{_netplan}, 3, "addresses:");
      foreach my $addr (@addresses) {
         AppendYaml($self->{_netplan}, 4, "- " . $addr);
      }
   }

   # netplan does not support multiple gateways
   # multiple gateways are problematic anyway and customers
   # should be advised to use a single gateway.
   my @ipv4Gateways =
      split(/,/, $self->{_customizationConfig}->Lookup($nic . "|GATEWAY"));

   if (@ipv4Gateways) {
      AppendYaml($self->{_netplan}, 3, "gateway4: " . $ipv4Gateways[0]);
   }

   my @ipv6Gateways =
      ConfigFile::ConvertToArray(
         $self->{_customizationConfig}->Query("^$nic(\\|IPv6GATEWAY\\|)"));

   if (@ipv6Gateways) {
      AppendYaml($self->{_netplan}, 3, "gateway6: " . $ipv6Gateways[0]);
   }

   # name servers
   my $dnsSuffices = $self->{_customizationConfig}->GetDNSSuffixes();
   my $dnsNameservers = $self->{_customizationConfig}->GetNameServers();

   if ($dnsSuffices && @$dnsSuffices || $dnsNameservers && @$dnsNameservers) {
      AppendYaml($self->{_netplan}, 3, "nameservers:");
   }

   if ($dnsSuffices && @$dnsSuffices) {
      AppendYaml($self->{_netplan}, 4, "search:");
      foreach my $suffix (@$dnsSuffices) {
         AppendYaml($self->{_netplan}, 5, "- " . $suffix);
      }
   }

   if ($dnsNameservers && @$dnsNameservers) {
      AppendYaml($self->{_netplan}, 4, "addresses:");
      foreach my $addr (@$dnsNameservers) {
         AppendYaml($self->{_netplan}, 5, "- " . $addr);
      }
   }
}

#...............................................................................
#
# CustomizeReslovFile
#
#     Skip the change to /etc/resolv.conf since the DNS settings are
#     already customized in /etc/netplan.
#
#     DNS is loaded by the systemd-resolved. Do not update /etc/resolv.conf
#     since systemd-resolved expose a stub resolver like 127.0.0.53 which
#     is not the real DNS servers. The real DNS servers can be checked
#     with "systemd-resolve --status"" command. They are pushed to
#     /run/systemd/resolve/resolv.conf by netplan and get picked up
#     by the systemd-resolved.
#
# Params & Result:
#     None.
#
#...............................................................................

sub CustomizeReslovFile
{
   INFO("Leave $Customization::RESOLVFILE unchanged.");
}

#...............................................................................
# See Customization.pm#RestartNetwork
#...............................................................................

sub RestartNetwork
{
   my ($self) = @_;
   my $ret;

   # Once the yaml file is dropped in /etc/netplan, systemctl restart
   # systemd-networkd would not pick up the new change because
   # systemd-networkd restart command only look for a network file under
   # /run directory. A reboot would reload that file with the change.
   # However, we should avoid a reboot. Use the netplan apply command to
   # apply the configuration change without a reboot. The netplan command
   # would update the files under /run/systemd/network and restart
   # systemd-networkd.

   Utils::ExecuteCommand('/usr/sbin/netplan apply 2>&1',
                         'Apply Netplan Settings',
                         \$ret);
   if ($ret) {
      die "Failed to apply netplan settings, return code: $ret";
   }
}

1;
